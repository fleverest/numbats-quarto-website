{
  "hash": "ecc616ca772fb5d35bceeea02be8a3ca",
  "result": {
    "markdown": "---\ntitle: \"Hexmaps with sugarbag make it easier to see the electoral map\"\nauthor: Di Cook\ndate: \"2022-05-21T00:00:00Z\"\nlastMod: \"2022-05-2T00:00:00Z\"\nimage: index_files/figure-html/hexmap-1.png\nfreeze: true\ncategories:\n  - data visualisation\n  - statistics\n  - teaching\n  - spatial data\ntags:\n  - R\n  - teaching\n  - data visualisation\nresources:\n  - map.html\n  - hexmap.html\n  - electoral_2022.csv\n---\n\n\n\n\nAustralia is a land of wide open spaces where the population concentrates in small areas. It can make for misleading map visualisations on statistics related to people. The May 20, 2022 ABC article [The Australian election map has been lying to you](https://www.abc.net.au/news/2022-05-20/federal-election-map-lying/101076016) explains this very neatly. It has alsp provided a better alternative to examine election results, in the form of a hexmap of Australia. The hexmap provided in the article is almost certainly manually constructed which is find for a construct once, use many times purpose.\n\nWhen you want to be able to make a hexmap on new spatial data or if the spatial groups change, the R package sugarbag can be helpful.  This post explains how to do this, using the results as we have them today from yesterday's election. (We'll update these once the final results are released.)\n\nHere's how to get started. Download the current spatial boundaries for electorates, from [Australian Electoral Commission web site](https://www.aec.gov.au/Electorates/maps.htm).\n\nLoad the libraries we need:\n\n\n::: {.cell hash='index_cache/html/libraries_74a7adc2ed561695d557d4ae7a6cf583'}\n\n```{.r .cell-code}\nlibrary(ggthemes)\nlibrary(sf)\nlibrary(sugarbag)\nlibrary(tidyverse)\nlibrary(plotly)\n```\n:::\n\n\nRead in the spatial polygons, defining the boundaries. These files can be very large, and slow to draw. For these visualisations faster to draw is more important, so the boundaries can be simplified using `rmapshaper::ms_simplify`.\n\n\n::: {.cell hash='index_cache/html/spatial-polygons_e584449b9280bf0b3376f0f9d1b3b364'}\n\n```{.r .cell-code}\n# Spatial polygons\nelectorates <- sf::st_read(\"2021-Cwlth_electoral_boundaries_ESRI/2021_ELB_region.shp\")\nelectorates_small <- electorates %>% rmapshaper::ms_simplify(keep = 0.01, keep_shapes = TRUE)\n```\n:::\n\n\nNext we need the election results. The ones here are manually  constructed from the [ABC results website](https://www.abc.net.au/news/elections/federal/2022/results?filter=all&sort=az&state=all). These results are joined to the map polygons, and colours are manually constructed to be one typically used by the party. The `ggplotly()` function enables labels to pop up on mouseover.\n\n\n::: {.cell hash='index_cache/html/electoral-map_def3e062ec7254c2697825e38454e30a'}\n\n```{.r .cell-code}\n# Read in data on current electoral results\nnew <- read_csv(\"electoral_2022.csv\") %>%\n  select(Electorate:Party)\nnew_major <- new %>%\n  mutate(Party_maj = fct_collapse(Party,\n         LNP = c(\"LIB\", \"LNP\", \"NAT\")))\nelectorates_small <- electorates_small %>%\n  left_join(new_major, by=c(\"Elect_div\"=\"Electorate\"))\nmap <- ggplot() +\n  geom_sf(data=electorates_small,\n                   aes(fill = Party_maj,\n                       label=Elect_div),\n                       colour=\"white\") +\n  scale_fill_manual(\"\", values=c(\"ALP\"=\"#E13940\",\n                                   \"LNP\"=\"#1C4F9C\",\n                                   \"GRN\"=\"#009C3D\",\n                                   \"KAP\"=\"#906E3E\",\n                                   \"CA\"=\"#FFC000\",\n                                   \"IND\"=\"#66b2b2\",\n                                   \"UNDEC\"=\"#808080\")) +\n  theme_map()\nmap\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/electoral-map-1.png){width=100%}\n:::\n\n```{.r .cell-code}\n#ggplotly(map)\n```\n:::\n\n\nAn interactive version can be found  [here](map.html).\n\nThe map is blue -- it looks like the coalition won the election in a landslide, doesn't it! (Please note the strange shape of the Cape of York is from the AEC spatial polygons provided! It is not due the the polygon thinning.)\n\nTo convert this into a hexmap, automatically with sugarbag, we need to\n\n1. Find the centroids of each polygon.\n2. Create a hexagon grid with a desired size of hexagon, `hs` controls this.\n3. Allocate electorates to a spot on the grid.\n4. Turn the hexagon centroids into hexagons.\n5. Join with election results.\n6. Make it interactive using `ggplotly()`.\n\n\n::: {.cell hash='index_cache/html/hexmap_c29b8cff851c96c8cf4bf3079f94f627'}\n\n```{.r .cell-code}\n# Find centroids of polygons\nsf_use_s2(FALSE)\ncentroids <- electorates %>%\n  create_centroids(., \"Elect_div\")\n\n## Create hexagon grid\nhs <- 0.8\ngrid <- create_grid(centroids = centroids,\n                    hex_size = hs,\n                    buffer_dist = 5)\n\n## Allocate polygon centroids to hexagon grid points\nelectorate_hexmap <- allocate(\n  centroids = centroids,\n  hex_grid = grid,\n  sf_id = \"Elect_div\",\n  ## same column used in create_centroids\n  hex_size = hs,\n  ## same size used in create_grid\n  hex_filter = 10,\n  focal_points = capital_cities,\n  width = 35,\n  verbose = FALSE\n)\n\n# Make the hexagons\ne_hex <- fortify_hexagon(data = electorate_hexmap,\n                            sf_id = \"Elect_div\",\n                            hex_size = hs)\nelectorate_hexmap_new <- e_hex %>%\n  left_join(new_major, by=c(\"Elect_div\"=\"Electorate\"))\nhexmap <- ggplot() +\n  geom_sf(data=electorates_small,\n          fill=\"grey90\", colour=\"white\") +\n  geom_polygon(data=electorate_hexmap_new,\n             aes(x=long, y=lat,\n                 group = hex_id,\n                 fill=Party_maj,\n                 label=Elect_div)) +\n  scale_fill_manual(\"\", values=c(\"ALP\"=\"#E13940\",\n                                 \"LNP\"=\"#1C4F9C\",\n                                 \"GRN\"=\"#009C3D\",\n                                 \"KAP\"=\"#906E3E\",\n                                 \"CA\"=\"#FFC000\",\n                                 \"IND\"=\"#66b2b2\",\n                                 \"UNDEC\"=\"#808080\")) +\n  theme_map()\nhexmap\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hexmap-1.png){width=100%}\n:::\n\n```{.r .cell-code}\n#ggplotly(hexmap)\n```\n:::\n\n\nAn interactive version can be found  [here](https://numbat.space/post/election_hexmaps/hexmap.html)\n\nAnd that's it! The sugarbag hexmap will expand the densely populated small areas outwards, while maintaining proximity to neighbouring electorates and to the city centre. It is a type of [cartogram algorithm](https://en.wikipedia.org/wiki/Cartogram) with two important differences: (1) uses equal area for each hexagon instead of sized proportional to population, and (2) allows some hexagons to be separated so that the geographic positions are reasonably preserved.\n\nThe hexmap makes it easier to see the results distributed across the country, and clearly with the predominance of red, that Labor won.\n\nData for this post can be found [here](https://numbat.space/post/election_hexmaps/electoral_2022.csv).\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"Creative Commons License\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" /></a><br />This work is licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}